[{"title":"js学习--继承","date":"2017-03-03T16:05:09.000Z","path":"2017/03/04/js学习-继承/","text":"js–原型与继承 1，原型（prototype）：函数对象的属性 12345678910ex: function Father(sex)&#123; this.sex=sex; this.height=180; say:function()&#123; return \"chinese\" &#125; &#125; Father.prototype.lastname=\"yang\"; var son=new Father(\"male\"); &gt;&gt;son.lastname //\"yang\" 2，对象关于原型的函数： propertyIsEnumerable():判断其中有哪些可枚举的属性 hasOwnProperty():判断属性是对象自身属性还是原型属性 isPrototypeOf()：判断当前对象是否是另一个对象的原型3，proto 对象指向原型的链接(某些浏览器支持)4，继承模式 （1）原型链 12345ex:function One()&#123;&#125; function Two()&#123;&#125; function Three()&#123;&#125; Two.prototype=new One(); Three.prototype=new Two(); 好处：对构造器One(),Two()的删除，修改不会影响原有的继承，因为继承的是构造器所创建的实体。 （因为这里的继承是对函数的原型进行替代重置，所以可能对这些对象[new One(),和new Two()]的constructor造成负面影响，所以需要重置constructor: 12Two.prototype.constructor=Two;Three.prototype.constructor=Three） (2)只继承于原型 12345678ex:function One()&#123;&#125; function Two()&#123;&#125; function Three()&#123;&#125; One.prototype.name=\"yang\"; Two.prototype=One.prototype; Two.prototype.constructor=Two; Three.prototype=Two.prototype; Three.prototype.constructor=Three; 负面影响：由于子对象和父对象均指向同一个对象，所以子对象对原型进行修改，父对象也会受影响。 如：&gt;&gt;&gt;Three.prototype.name=&quot;chen&quot;; var someone=new One(); someone.name &gt;&gt;&gt;&quot;chen&quot; (3)临时构造器 new F() 1234567891011ex:function One()&#123;&#125; function Two()&#123;&#125; function Three()&#123;&#125; var F=function()&#123;&#125;; F.prototype=One.prototype; Two.prototype=new F(); Two.prototype.constructor=Two; var F=function()&#123;&#125;; F.prototype=Two.prototype; Three.prototype=new F(); Three.prototype.constructor=Three; 好处：使得子对象不影响父对象 （4）将继承封装成一个函数： 123456ex:function extend(child,parent)&#123;var F=function()&#123;&#125;;F.prototype=parent.prototype;child.prototype=new F();child.uber=parent.prototype;&#125; （5）属性拷贝 12345678ex:function extend2(child,parent)&#123;var a=child.prototye;var b=parent.prototype;for(var i in b)&#123;a[i]=b[i];&#125;a.uber=b&#125; 说明：仅适用于包含基本数据类型属性的拷贝，对于对象类型（函数和数组）属性是引用传递 负面影响：因为对象类型的拷贝属于引用传递，所以子对象原型对拷贝来的对象属性进行修改时会影响父对象的原型（如果是重写则不会） （6）对象之间的继承 说明：抛弃构造器直接实现对象间的继承（用的也是对象之间的继承） 1234567ex:function extendcopy(a)&#123; var b=&#123;&#125; for(var i in a)&#123; b[i]=a[i]; &#125; b.uber=a&#125; （7）深拷贝（解决属性拷贝中对象属性的引用传递问题） 说明：深拷贝对于基本数据类型和对象属性都采用新建的形式，所以对子对象属性的修改不会影响到父对象 实现函数: 1234567891011function deepcopy(child,parent)&#123; var child=child || &#123;&#125;; for(var i in parent)&#123; if(typeof parent[i]===\"object\")&#123; child[i]=(child[i].constructor === Array)?[]:&#123;&#125;; deepcopy(child[i],parent[i]); &#125;else&#123; child[i]=parent[i] &#125; &#125;&#125; (ps:多么巧妙的设计) （8）原型继承 说明：函数接收父对象，并返回以该父对象为原型的对象 12345678ex:function object(o)&#123;var n;function F()&#123;&#125;F.prototype=o;n=new F();n.uber=o;return n;&#125; （9）原型继承和属性拷贝混合（对一个对象采用原型继承，对其他对象用属性拷贝） 123456789101112ex:function fix(o,stuff)&#123;var n;function F()&#123;&#125;F.prototype=o;n=new F();n.uber=o;for(var i in stuff)&#123;n[i]=stuff[i];&#125;return n;&#125; (10)多重继承（对多个对象进行属性拷贝） 12345678910ex:function multi()&#123;var n=&#123;&#125;,stuff,len=arguments.length;for(i=0;i&lt;len;i++)&#123; stuff=arguments[i]; for(var j in stuff)&#123; n[j]=stuff[j]; &#125;&#125;return n;&#125; (11)构造器继承[call(),apply()] 优势：“当我们创建一个继承于数组或者其他对象类型的子对象时，将获得一个完完全全的新值，而不是一个引用，对其做修改不会影响父对象” 1234567891011121314151617181920212223242526272829ex:function father()&#123;this.lastname=\"yang\";&#125;father.prototype.height=180;function son()&#123;father.apply(this,arguments);&#125;son.prototype=new father();son.prototype.study=\"good\";(^父对象构造器会被调用两次)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;改造方法：ex:function father()&#123;this.lastname=\"yang\";&#125;father.prototype.height=180;function son()&#123;father.apply(this,arguments);&#125;//var a=son.prototye;//var b=father.prototype;//for(var i in b)&#123;//a[i]=b[i];//&#125;执行对原型属性的拷贝a.uber=b //son.prototype=new father();son.prototype.study=\"good\"; ###整理如下：","tags":[{"name":"js","slug":"js","permalink":"https://yangxiaosen.github.io/tags/js/"}]},{"title":"JS学习--正则表达式","date":"2017-02-22T14:12:32.000Z","path":"2017/02/22/JS学习-正则表达式/","text":"本文记录js学习过程中的一些内容对js正则表达式做个记录，以便用到时备查推荐教程：正则表达式30分钟入门教程 一、元字符1，\\b 单词的开头结尾，即单词的分界处2，\\d 一位数字（0，1…）3， . 匹配除换行符(\\n)以外的任意字符4， * 重复任意次5， + 重复一次或更多次6， ^ 匹配字符串的开始7， $ 匹配字符串的结束8, \\w 匹配字母或数字或下划线或汉字9，\\s 匹配任意的空白符10，\\ 转义字符 二，字符的重复方式1, * 重复零次或更多次2, + 重复一次或更多次3, ? 重复零次或一次4, {n} 重复n次5, {n,} 重复n次或更多次6, {n,m} 重复n到m次 三，匹配字符集[]ex:[aeiou] 匹配a或e或i或o或u 四，分枝条件 |ex: 0\\d{2}-\\d{8}|0\\d{3}-\\d{7} 匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445) 五，反义\\W 匹配任意不是字母，数字，下划线，汉字的字符\\S 匹配任意不是空白符的字符\\D 匹配任意非数字的字符\\B 匹配不是单词开头或结束的位置[^x] 匹配除了x以外的任意字符[^aeiou] 匹配除了aeiou这几个字母以外的任意字符 六，零宽断言1，(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)2， (?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)3，零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\\d{3}(?!\\d)匹配三位数字，而且这三位数字的后面不能是数字4，(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\\d{7}匹配前面不是小写字母的七位数字 七，js中关于正则表达式的方法，属性1，RegExp对象：正则表达式 var reg=new RegExp(“a.b”); 文本标识法：var reg=/a.b/;2，RegExp对象属性： global:(g)默认为false,如果要将正则表达式匹配到第一个不结束继续匹配下去则设为ture ignoreCase:(i)默认为false,设置大小写相关性 multiline:(m)默认false,设置是否跨行搜索 lastIndex:搜索开始的索引位 source:用于储存正则表达式匹配模式的属性 12ex:var reg=new RegExp(\"a.*b\",\"gmi\"); 或：var reg=/a.*b/igm; 3，RegExp对象方法 （1）查找匹配方法： test()：返回布尔值，找到内容为true，反之为false exec()：返回匹配到的内容的数组 12ex: /a.*b/i.test('Addbanb'); //true /a.*b/i.exec('Addbanb'); //[\"Addbanb\"] (2)以RegExp对象为参数的字符串方法： match()：返回包含匹配内容的数组 12ex: \"helloworld\".match(/l/); //['l']ex: \"helloworld\".match(/l/g); //['l','l','l'] search()：返回第一个匹配内容所在的位置 1ex: \"helloworld\".search(/l/); //2 replace()：将匹配文本替换成其他内容 1ex：\"helloWorld\".replace(/[A-Z]/g,''); //\"helloorld\" split(): 根据正则表达式将字符串分割成若干个数组元素 1ex: \"2:3:4:5\".split(\":\") //将返回[\"2\", \"3\", \"4\", \"5\"]","tags":[{"name":"js","slug":"js","permalink":"https://yangxiaosen.github.io/tags/js/"}]},{"title":"JS学习--对象","date":"2017-02-19T13:34:54.000Z","path":"2017/02/19/JS学习-对象/","text":"本文记录js学习过程中的一些内容js对象 1访问对象属性可以用.或者[]例：1yangxiaosen.name yangxiaosen['name'] 2如果访问的属性名是不确定的，必须用[]var key='name';1yangxiaosen[&apos;key&apos;] 3 1234567function Hero(name)&#123;this.name=name;this.occupation='monica';this.whoareyou=function()&#123;return 'i am'+this.name+'and i am'+this.occupation;&#125;&#125; 1var hero=Hero('yang') 结果返回undefine 因为没有用new 关键字，所以没有创建新对象，只是像其他函数一样执行，又由于函数中没有return语句，所以 返回undefine，此时函数中的this的值是全局对象。 41234function C2()&#123; this.a=1;return &#123;b:2&#125;; &#125; var c1=new C2(); c1.a //undefine c1.b //=2 5拷贝某个对象或者将对象传递给某个变量，则对这个变量所做的操作都是会影响原有的对象 6 123var o=&#123;&#125;;alert(o) 和 alert(o.toString())是等价的\"i am:\"+o 和 \"i am:\"+o.toString()是等价的 7 函数对象的length属性用来记录对象的参数数量 812345678910111213call()和apply() //改变函数对象的this引用为第一个参数var some_obj=&#123;name:\"someone\",say:function(who)&#123; return \"hey\"+who+\"i am \"+this.name;&#125;&#125;;var my_obj=&#123;name:\"yangxiaosen\"&#125;;some_obj.say.call(my_obj,\"dude\")等效于some_obj.say.apply(my_obj,[\"dude\"]) 9 Number 对象提供了toString(radix)方法，其中radix为进制值 10 String对象提供了转换大小写方法： 1toUpperCase()和toLowerCase() 字符串内部搜索 1234var s=\"jejfweafbd\";s.indexOf('e') //1s.indexOf('e',2) //5,搜索从2开始s.lastIndexOf('e') //4，搜索从后面开始","tags":[{"name":"js","slug":"js","permalink":"https://yangxiaosen.github.io/tags/js/"}]},{"title":"Hexo+github搭建个人博客","date":"2017-02-07T16:32:01.000Z","path":"2017/02/08/Hexo-github搭建个人博客/","text":"初衷作为程序猿，有个自己的博客可以记录自己的学习历程，其中使用github和hexo的配合又是最省时省力的选择，况且hexo拥有很多简洁优美的主题可供选择 准备github安装关于github的安装，网上例子很多，随手甩个链接github安装使用 Node.js安装下载Node.js，一路next即可 安装hexo在任意位置点击鼠标右键，选择Git bash，执行以下npm命令1npm install -g hexo 创建文件夹在你想要存放博客文件的任意位置，执行以下命令(点击鼠标右键，选择Git bash)1hexo init 安装依赖1npm install 到这里，本地博客已经建立完毕 上传到github到github上创建仓库，这个仓库的名字需要和你的账号对应，格式: yourname.github.io，比如我的仓库名为yangxiaosen.github.io 生成SSH密钥1ssh-keygen -t rsa -C \"你的邮箱地址\" 按3个回车，表示密码为空 在C:\\Users\\Administrator.ssh下，得到两个文件id_rsa和id_rsa.pub。 在GitHub上添加SSH密钥 打开id_rsa.pub，复制全文。https://github.com/settings/ssh ，Add SSH key，粘贴进去执行12hexo ghexo d 将博客部署到github到这里，博客搭建完毕，博客地址为 https://yourname.github.io, 配置关于博客的配置主要在根目录的_config.yml文件进行配置 hexo常用命令hexo help #查看帮助 hexo init #初始化一个目录 hexo new \"postName\" #新建文章 hexo new page \"pageName\" #新建页面 hexo generate #生成网页，可以在 public 目录查看整个网站的文件 hexo server #本地预览，'Ctrl+C'关闭 hexo deploy #部署.deploy目录 hexo clean #清除缓存","tags":[{"name":"hexo","slug":"hexo","permalink":"https://yangxiaosen.github.io/tags/hexo/"}]},{"title":"Hello World","date":"2017-02-04T14:58:13.478Z","path":"2017/02/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]